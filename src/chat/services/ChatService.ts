import { IChatMessageRepository } from '../../domain/repositories/IChatMessageRepository';
import { IUserRepository } from '../../domain/repositories/IUserRepository';
import { ISubscriptionBundleRepository } from '../../domain/repositories/ISubscriptionBundleRepository';
import { IUserMonthlyUsageRepository } from '../../domain/repositories/IUserMonthlyUsageRepository';
import { QuotaExceededError, NotFoundError } from '../../domain/errors/AppError';
import { ChatMessage } from '../../domain/entities/ChatMessage';
import { UserMonthlyUsage } from '../../domain/entities/UserMonthlyUsage';

export interface ChatResponse {
  question: string;
  answer: string;
  tokensUsed: number;
}

export class ChatService {
  constructor(
    private chatMessageRepository: IChatMessageRepository,
    private userRepository: IUserRepository,
    private subscriptionBundleRepository: ISubscriptionBundleRepository,
    private userMonthlyUsageRepository: IUserMonthlyUsageRepository
  ) {}

  async sendMessage(userId: string, question: string): Promise<ChatResponse> {
    // Verify user exists
    const user = await this.userRepository.findById(userId);
    if (!user) {
      throw new NotFoundError('User');
    }

    // Check and update monthly usage
    const now = new Date();
    const year = now.getFullYear();
    const month = now.getMonth() + 1;

    let monthlyUsage = await this.userMonthlyUsageRepository.findByUserIdAndMonth(
      userId,
      year,
      month
    );

    // Auto-reset free quota on the 1st of each month
    if (monthlyUsage && monthlyUsage.lastResetDate.getDate() !== 1 && now.getDate() === 1) {
      await this.userMonthlyUsageRepository.resetMonthlyQuota(userId, year, month);
      monthlyUsage = await this.userMonthlyUsageRepository.findByUserIdAndMonth(userId, year, month);
    }

    // Initialize monthly usage if doesn't exist
    if (!monthlyUsage) {
      monthlyUsage = await this.userMonthlyUsageRepository.create({
        userId,
        year,
        month,
        messagesUsed: 0,
        lastResetDate: now,
      });
    }

    // Check if user can use free quota
    const canUseFreeQuota = monthlyUsage.canUseFreeQuota();

    if (!canUseFreeQuota) {
      // Check for active subscription bundle with quota
      const activeBundle = await this.subscriptionBundleRepository.findLatestActiveWithQuota(userId);

      if (!activeBundle || !activeBundle.canUse()) {
        throw new QuotaExceededError(
          'You have exceeded your free monthly quota. Please subscribe to a bundle to continue.'
        );
      }

      // Deduct from bundle (only if not unlimited)
      if (activeBundle.maxMessages !== -1) {
        const newMessagesUsed = activeBundle.messagesUsed + 1;
        await this.subscriptionBundleRepository.updateMessagesUsed(activeBundle.id, newMessagesUsed);
      }
    } else {
      // Use free quota
      const newMessagesUsed = monthlyUsage.messagesUsed + 1;
      monthlyUsage = new UserMonthlyUsage(
        monthlyUsage.id,
        monthlyUsage.userId,
        monthlyUsage.year,
        monthlyUsage.month,
        newMessagesUsed,
        monthlyUsage.lastResetDate,
        monthlyUsage.createdAt,
        monthlyUsage.updatedAt
      );
      await this.userMonthlyUsageRepository.update(monthlyUsage);
    }

    // Simulate OpenAI API call with delay
    const delay = parseInt(process.env.OPENAI_MOCK_DELAY_MS || '1000', 10);
    await this.sleep(delay);

    // Mock OpenAI response
    const answer = this.generateMockResponse(question);
    const tokensUsed = this.calculateTokens(question, answer);

    // Store message
    const chatMessage = await this.chatMessageRepository.create({
      userId,
      question,
      answer,
      tokensUsed,
    });

    return {
      question: chatMessage.question,
      answer: chatMessage.answer,
      tokensUsed: chatMessage.tokensUsed,
    };
  }

  private generateMockResponse(question: string): string {
    // Simple mock response generator
    return `This is a mocked response to your question: "${question}". In a real implementation, this would be generated by OpenAI's API.`;
  }

  private calculateTokens(question: string, answer: string): number {
    // Simple token estimation (roughly 4 characters per token)
    const totalChars = question.length + answer.length;
    return Math.ceil(totalChars / 4);
  }

  private sleep(ms: number): Promise<void> {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }

  async getChatHistory(userId: string, limit: number = 50): Promise<ChatMessage[]> {
    const user = await this.userRepository.findById(userId);
    if (!user) {
      throw new NotFoundError('User');
    }

    return this.chatMessageRepository.findByUserId(userId, limit);
  }
}

